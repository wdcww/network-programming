# 多路I/O复用

虽然，多进程（../server_mp/）和多线程（../server_mt/）的两个版本的server端程序较../server/已经高效了不少【指可以并发】，
但是，它们是需要工作在用户态的服务器程序亲自去监听，然后有client请求时进行后续工作。

这样的机制没有高效地利用系统资源进行并发处理，也没有利用了内核的强大能力。
而且，服务器程序不可能将大部分的资源放在通信上，应当有自己的其他的业务。

server_multi_IO/ 下的几种版本的server程序，相当于是请了一个秘书专门来负责监听。下面展开说说select、poll、epoll、epoll reactor，
它们都是都是将文件描述符的监视放在内核态的机制，使得在用户态的服务器程序可以进行其他操作无需阻塞等待 I/O 事件。

## 1 select
*  相同的是，服务器端调用 socket() 创建一个lfd，然后bind()到一个特定的地址和端口，最后使用listen()开始监听连接请求。

* 不同的是，服务器将lfd添加到一个文件描述符集合，调用 select 函数，将控制权交给内核，内核会监视 集合 中的文件描述符是否有事件发生。
```
select 函数在内核中运行，服务器将监听的 lfd 交给 select 来监视。
当有新的连接请求到达时，select会通知服务器，服务器再调用accept创建一个新的连接套接字。
这个流程保证了服务器能够同时监视多个文件描述符并处理 I/O 事件。
```
_在内核态_，select进行文件描述符监视，这样服务器在用户态可以释放资源用于其他业务逻辑的处理。

_在用户态_，服务器可以进行其他操作，无需阻塞等待 I/O 事件。



## 2 poll




## 3 epoll



## 4 epoll reactor

